% --- ARQUIVO COMPLETO: 1-introducao.tex (VERSÃO FINAL CORRIGIDA) ---

\begin{frame}
\frametitle{Sumário}
\tableofcontents
\end{frame}

\section{Introdução e Definição do Problema}

% SLIDE 2: O GANCHO
\begin{frame}
\frametitle{Qual é o melhor caminho?}
\begin{columns}[T,onlytextwidth]
    \begin{column}{0.6\textwidth}
        \begin{block}{A Pergunta Intuitiva}
        Como o Google Maps sabe a rota mais rápida para chegar na FCT?
        \end{block}
        \begin{itemize}
            \item É o caminho mais rápido (menor tempo)?
            \item É o caminho mais curto (menor distância)?
            \item É o caminho mais barato (sem pedágios)?
        \end{itemize}
        \vspace{0.5cm}
        A ideia central é modelar o mapa como um \textbf{grafo} e atribuir \textbf{custos} às ruas.
    \end{column}
    \begin{column}{0.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/googlemaps.png}
    \end{column}
\end{columns}
\end{frame}

% SLIDE 3: APLICAÇÕES PRÁTICAS
\begin{frame}
\frametitle{Onde o PCM se Esconde?}
\begin{itemize}
    \item \textbf{Redes de Computadores:} Roteamento de pacotes na internet (Protocolo OSPF) — o custo é a latência.
    \item \textbf{Logística e Transporte:} Otimização de rotas de entrega (Correios, Mercado Livre) — o custo é a distância ou tempo.
    \item \textbf{Finanças (Avançado):} Detecção de oportunidades de arbitragem em mercados (encontrar ciclos de custo negativo).
    \item \textbf{Análise de Redes Sociais:} Medir o "grau de separação" entre duas pessoas.
\end{itemize}
\end{frame}

% SLIDE 4: DEFINIÇÃO FORMAL - PARTE 1
\begin{frame}
\frametitle{Traduzindo o Mapa para a Matemática}
\begin{columns}[T,onlytextwidth]
    \begin{column}{0.6\textwidth}
        \begin{itemize}
            \item \textbf{Grafo (ou Dígrafo):} $G = (V, E)$
            \item \textbf{$V$ (Vértices):} O conjunto de "nós" (ex: cidades, roteadores).
            \item \textbf{$E$ (Arestas):} O conjunto de "conexões" (ex: ruas, cabos).
            \item \textbf{Grafo Ponderado:} Cada aresta $(i, j) \in E$ possui um \textbf{peso} (ou custo) $w_{ij}$ associado.
        \end{itemize}
    \end{column}
    \begin{column}{0.4\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.8, every node/.style={circle, draw, minimum size=0.6cm}]
            \node (A) at (0,0) {A};
            \node (B) at (2.5,0) {B};
            \node (C) at (0,-2) {C};
            \node (D) at (2.5,-2) {D};
            \draw[->] (A) -- node[above, font=\small]{5} (B);
            \draw[->] (A) -- node[left, font=\small]{10} (C);
            \draw[->] (B) -- node[right, font=\small]{3} (C);
            \draw[->] (B) -- node[right, font=\small]{7} (D);
        \end{tikzpicture}
    \end{column}
\end{columns}
\end{frame}

% SLIDE 5: DEFINIÇÃO FORMAL - PARTE 2
\begin{frame}
\frametitle{O Problema de Caminhos Mínimos}
\begin{itemize}
    \item \textbf{Caminho:} Uma sequência de arestas que conecta um nó origem $s$ a um nó destino $t$.
    \begin{itemize}
        \item Ex: $P = (A \to B \to D)$
    \end{itemize}
    \item \textbf{Custo do Caminho:} A soma dos pesos $w_{ij}$ das arestas que formam o caminho.
    \begin{itemize}
        \item Ex: $Custo(P) = w_{AB} + w_{BD}$
    \end{itemize}
\end{itemize}
 \begin{block}{O Grande Objetivo}
    Dado um grafo ponderado $G$, um nó origem $s$ e um nó destino $t$, encontrar o caminho $P$ de $s$ para $t$ que \textbf{minimiza o custo total}.
    \[
      P^* = \arg\min_{P:\, s\to t} \sum_{(i,j)\in P} w_{ij}
    \]
 \end{block}
 \begin{alertblock}{Observação Importante}
    Os algoritmos que vamos estudar (Dijkstra, Bellman-Ford) resolvem o problema de \textbf{Origem Única (SSSP)}: encontram o caminho mínimo de $s$ para \textbf{TODOS} os outros nós.
 \end{alertblock}
\end{frame}

% --- MÓDULO 2: MODELO MATEMÁTICO ---

\section{Modelo Matemático (PL)}

% SLIDE 6: A Abordagem Genérica
\begin{frame}
\frametitle{Modelo PL: A Abordagem Genérica}
\begin{itemize}
    \item \textbf{Ideia:} Modelar como um \textbf{Problema de Fluxo} para enviar 1 unidade da origem $s$ ao destino $t$.
\end{itemize}
\begin{block}{Variáveis de Decisão}
$x_{ij} = 1$ se o arco $(i, j)$ for usado no caminho, $0$ caso contrário.
\end{block}
\begin{block}{Função Objetivo (Minimizar o Custo Total)}
Minimizar a soma dos custos de todas as arestas usadas:
\[
\min Z = \sum_{(i,j) \in E} w_{ij} \cdot x_{ij}
\]
\end{block}
\begin{block}{Restrições (Conservação de Fluxo)}
\begin{itemize}
    \item \textbf{Origem (s):} Fluxo que Sai = 1
    \item \textbf{Intermediário (k):} Fluxo que Entra = Fluxo que Sai
    \item \textbf{Destino (t):} Fluxo que Entra = 1
\end{itemize}
\end{block}
\end{frame}

% SLIDE 7: Exemplo de Modelagem (Grafo A-E)
\begin{frame}
\frametitle{Exemplo de Modelagem: Grafo Logístico}
\begin{itemize}
    \item Vamos modelar o problema de achar a rota de custo mínimo da Origem \textbf{A} para o Destino \textbf{E}.
\end{itemize}
\begin{columns}[T,onlytextwidth]
    \begin{column}{0.5\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.85, every node/.style={circle, draw, minimum size=0.7cm}]
            \node (A) at (0, 2) {A};
            \node (B) at (3, 4) {B};
            \node (C) at (3, 0) {C};
            \node (D) at (6, 2) {D};
            \node (E) at (9, 2) {E};
            
            \draw[->] (A) -- node[above, font=\small]{4} (B);
            \draw[->] (A) -- node[below, font=\small]{2} (C);
            \draw[->] (B) -- node[left, font=\small]{1} (C);
            \draw[->] (B) -- node[above, font=\small]{5} (D);
            \draw[->] (C) -- node[below, font=\small]{8} (D);
            \draw[->] (C) -- node[below, font=\small]{10} (E);
            \draw[->] (D) -- node[above, font=\small]{3} (E);
        \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
        \textbf{Custos ($w_{ij}$):}
        \begin{itemize}
            \item $w_{AB} = 4$
            \item $w_{AC} = 2$
            \item $w_{BC} = 1$
            \item $w_{BD} = 5$
            \item $w_{CD} = 8$
            \item $w_{CE} = 10$
            \item $w_{DE} = 3$
        \end{itemize}
    \end{column}
\end{columns}
\end{frame}

% SLIDE 8: O PPL Completo
\begin{frame}
\frametitle{Exemplo de Modelagem: O PPL Completo}

\textbf{Função Objetivo (Minimizar Z):}
% Use 'tiny' para garantir que a F.O. caiba na linha
\begin{tiny}
\[
\min Z = 4x_{AB} + 2x_{AC} + 1x_{BC} + 5x_{BD} + 8x_{CD} + 10x_{CE} + 3x_{DE}
\]
\end{tiny}
\textbf{Sujeito a (Conservação de Fluxo):}
% Use 'scriptsize' para diminuir as equações
\begin{scriptsize} 
\begin{align*}
(x_{AB} + x_{AC}) - 0 &= 1 && \text{(Nó A: Origem)} \\
(x_{BC} + x_{BD}) - x_{AB} &= 0 && \text{(Nó B: Intermediário)} \\
(x_{CD} + x_{CE}) - (x_{AC} + x_{BC}) &= 0 && \text{(Nó C: Intermediário)} \\
(x_{DE}) - (x_{BD} + x_{CD}) &= 0 && \text{(Nó D: Intermediário)} \\
0 - (x_{CE} + x_{DE}) &= -1 && \text{(Nó E: Destino)} \\
x_{ij} &\ge 0
\end{align*}
\end{scriptsize}
\end{frame}

% SLIDE 9: A MÁGICA DA PROGRAMAÇÃO LINEAR
\begin{frame}
\frametitle{Modelo PL: A Mágica da Integridade}
\begin{itemize}
    \item \textbf{Pergunta:} Nós não deveríamos forçar $x_{ij}$ a ser um número inteiro ($0$ ou $1$)?
    \[
    x_{ij} \in \{0, 1\} \quad \text{(Programação Inteira)}
    \]
    \item \textbf{Resposta:} Não precisa!
    \item Este tipo de problema de rede (Fluxo de Custo Mínimo) tem uma propriedade especial chamada \textbf{Total Unimodularidade}.
    \item \textbf{O que importa:} Essa propriedade \textbf{garante} que, se a oferta (1) e a demanda (1) são inteiras, a solução ótima do problema de Programação Linear (com $x_{ij} \ge 0$) \textbf{já será inteira}.
\end{itemize}
\end{frame}

% --- MÓDULO 3: MÉTODOS DE RESOLUÇÃO ---

\section{Métodos de Resolução}

% SLIDE 10: INTRODUÇÃO AOS ALGORITMOS
\begin{frame}
\frametitle{Módulo 3: Métodos de Resolução}
\begin{itemize}
    \item Embora o modelo de PL seja academicamente correto, ele não é a forma mais \textit{eficiente} de resolver o Problema de Caminhos Mínimos na prática.
    \item Na prática, usamos algoritmos especializados em grafos que são muito mais rápidos.
    \item Vamos focar em dois algoritmos fundamentais:
    \begin{enumerate}
        \item \textbf{Algoritmo de Dijkstra}
        \item \textbf{Algoritmo de Bellman-Ford}
    \end{enumerate}
\end{itemize}
\end{frame}

% SLIDE 11: ALGORITMO DE DIJKSTRA (CONCEITO)
\begin{frame}
\frametitle{Algoritmo de Dijkstra}
\begin{block}{O Conceito}
Uma abordagem "Gulosa" (Greedy). A cada passo, ele escolhe o caminho que \textit{parece} ser o melhor (o mais curto) e expande a partir dele.
\end{block}

\begin{alertblock}{Restrição Crítica}
O Algoritmo de Dijkstra \textbf{NÃO FUNCIONA} se o grafo tiver arestas com \textbf{pesos negativos}.
\end{alertblock}
\end{frame}

% --- SLIDES 12-17: Exercício de Dijkstra ---
\begin{frame}
\frametitle{Exercício: Algoritmo de Dijkstra (Inicialização)}
% Usar \begin{columns} garante que o grafo e o texto fiquem lado a lado
\begin{columns}[T,onlytextwidth]
    \begin{column}{0.5\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.9, every node/.style={circle, draw, minimum size=0.7cm}]
            \node[fill=gray!30] (A) at (0, 2) {A}; % Nó inicial
            \node (B) at (3, 4) {B};
            \node (C) at (3, 0) {C};
            \node (D) at (6, 2) {D};
            \node (E) at (9, 2) {E};
            
            \draw[->] (A) -- node[above, font=\small]{4} (B);
            \draw[->] (A) -- node[below, font=\small]{2} (C);
            \draw[->] (B) -- node[left, font=\small]{1} (C);
            \draw[->] (B) -- node[above, font=\small]{5} (D);
            \draw[->] (C) -- node[below, font=\small]{8} (D);
            \draw[->] (C) -- node[below, font=\small]{10} (E);
            \draw[->] (D) -- node[above, font=\small]{3} (E);
        \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
        	extbf{Nós Visitados: \{\}}
        {\footnotesize\setlength{\tabcolsep}{6pt}\renewcommand{\arraystretch}{1.1}%
        \begin{tabular}{c|c|c}
        	extbf{Nó} & \textbf{dist[i]} & \textbf{prev[i]} \\ \hline
        A & \textbf{0} & - \\
        B & $\infty$ & - \\
        C & $\infty$ & - \\
        D & $\infty$ & - \\
        E & $\infty$ & - \\
        \end{tabular}}
        \medskip
        \textbf{Próximo nó:} A (custo 0)
    \end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Exercício: Dijkstra - Iteração 1 (Nó A)}
\begin{columns}[T,onlytextwidth]
    \begin{column}{0.5\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.85, every node/.style={circle, draw, minimum size=0.7cm}]
            \node[fill=gray!30] (A) at (0, 2) {A}; 
            \node[fill=blue!30] (B) at (3, 4) {B}; % Alcançado
            \node[fill=red!30] (C) at (3, 0) {C}; % Alcançado e menor
            \node (D) at (6, 2) {D};
            \node (E) at (9, 2) {E};
            
            \draw[->,line width=2pt] (A) -- node[above, font=\small]{4} (B); % Caminho usado
            \draw[->,line width=2pt] (A) -- node[below, font=\small]{2} (C); % Caminho usado
            \draw[->] (B) -- node[left, font=\small]{1} (C);
            \draw[->] (B) -- node[above, font=\small]{5} (D);
            \draw[->] (C) -- node[below, font=\small]{8} (D);
            \draw[->] (C) -- node[below, font=\small]{10} (E);
            \draw[->] (D) -- node[above, font=\small]{3} (E);
        \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
        \textbf{Visitando Nó: A} (dist=0)
        \begin{itemize}
            \item Vizinho B: $0 + 4 = 4$. (Atualiza dist[B]=4, prev[B]=A)
            \item Vizinho C: $0 + 2 = 2$. (Atualiza dist[C]=2, prev[C]=A)
        \end{itemize}
        	extbf{Nós Visitados: \{A\}}
    {\footnotesize\setlength{\tabcolsep}{6pt}\renewcommand{\arraystretch}{1.1}%
    \begin{tabular}{c|c|c}
        	extbf{Nó} & \textbf{dist[i]} & \textbf{prev[i]} \\ \hline
    A & 0 & - \\
    B & \textbf{4} & A \\
    C & \textbf{2} & A \\
    D & $\infty$ & - \\
    E & $\infty$ & - \\
    \end{tabular}}
    \medskip
        \textbf{Próximo nó:} C (menor dist=2)
    \end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Exercício: Dijkstra - Iteração 2 (Nó C)}
\begin{columns}[T,onlytextwidth]
    \begin{column}{0.5\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.85, every node/.style={circle, draw, minimum size=0.7cm}]
            \node[fill=gray!30] (A) at (0, 2) {A}; 
            \node[fill=red!30] (B) at (3, 4) {B}; % Menor
            \node[fill=gray!30] (C) at (3, 0) {C}; % Visitado
            \node[fill=blue!30] (D) at (6, 2) {D}; % Alcançado
            \node[fill=blue!30] (E) at (9, 2) {E}; % Alcançado
            
            \draw[->] (A) -- node[above, font=\small]{4} (B); 
            \draw[->,line width=2pt] (A) -- node[below, font=\small]{2} (C); % Caminho usado
            \draw[->] (B) -- node[left, font=\small]{1} (C);
            \draw[->] (B) -- node[above, font=\small]{5} (D);
            \draw[->,line width=2pt] (C) -- node[below, font=\small]{8} (D); % Caminho usado
            \draw[->,line width=2pt] (C) -- node[below, font=\small]{10} (E); % Caminho usado
            \draw[->] (D) -- node[above, font=\small]{3} (E);
        \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
        \textbf{Visitando Nó: C} (dist=2)
        \begin{itemize}
            \item Vizinho D: $2 + 8 = 10$. (Atualiza dist[D]=10, prev[D]=C)
            \item Vizinho E: $2 + 10 = 12$. (Atualiza dist[E]=12, prev[E]=C)
        \end{itemize}
        	extbf{Nós Visitados: \{A, C\}}
    {\footnotesize\setlength{\tabcolsep}{6pt}\renewcommand{\arraystretch}{1.1}%
    \begin{tabular}{c|c|c}
        	extbf{Nó} & \textbf{dist[i]} & \textbf{prev[i]} \\ \hline
    A & 0 & - \\
    B & 4 & A \\
    C & 2 & A \\
    D & \textbf{10} & C \\
    E & \textbf{12} & C \\
    \end{tabular}}
    \medskip
        \textbf{Próximo nó:} B (menor dist=4)
    \end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Exercício: Dijkstra - Iteração 3 (Nó B) - A "Relaxação"}
\begin{columns}[T,onlytextwidth]
    \begin{column}{0.5\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.85, every node/.style={circle, draw, minimum size=0.7cm}]
            \node[fill=gray!30] (A) at (0, 2) {A}; 
            \node[fill=gray!30] (B) at (3, 4) {B}; % Visitado
            \node[fill=gray!30] (C) at (3, 0) {C}; 
            \node[fill=red!30] (D) at (6, 2) {D}; % Menor
            \node[fill=blue!30] (E) at (9, 2) {E}; 
            
            \draw[->,line width=2pt] (A) -- node[above, font=\small]{4} (B); 
            \draw[->] (A) -- node[below, font=\small]{2} (C); 
            \draw[->] (B) -- node[left, font=\small]{1} (C);
            \draw[->,line width=2pt] (B) -- node[above, font=\small]{5} (D); % Caminho usado
            \draw[->] (C) -- node[below, font=\small]{8} (D);
            \draw[->] (C) -- node[below, font=\small]{10} (E);
            \draw[->] (D) -- node[above, font=\small]{3} (E);
        \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
        \textbf{Visitando Nó: B} (dist=4)
        \begin{itemize}
            \item Vizinho C: Já visitado.
            \item Vizinho D: $4 + 5 = 9$.
            \item O custo atual de D é 10. \textbf{Como 9 < 10, atualizamos!}
            \item (Atualiza dist[D]=9, prev[D]=B)
        \end{itemize}
        	extbf{Nós Visitados: \{A, C, B\}}
    {\footnotesize\setlength{\tabcolsep}{6pt}\renewcommand{\arraystretch}{1.1}%
    \begin{tabular}{c|c|c}
        	extbf{Nó} & \textbf{dist[i]} & \textbf{prev[i]} \\ \hline
    A & 0 & - \\
    B & 4 & A \\
    C & 2 & A \\
    D & \textbf{9} & \textbf{B} \\
    E & 12 & C \\
    \end{tabular}}
    \medskip
        \textbf{Próximo nó:} D (menor dist=9)
    \end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Exercício: Dijkstra - Iterações 4 e 5 (Nós D, E)}
\begin{columns}[T,onlytextwidth]
    \begin{column}{0.5\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.85, every node/.style={circle, draw, minimum size=0.7cm}]
            \node[fill=gray!30] (A) at (0, 2) {A}; 
            \node[fill=gray!30] (B) at (3, 4) {B}; 
            \node[fill=gray!30] (C) at (3, 0) {C}; 
            \node[fill=gray!30] (D) at (6, 2) {D}; % Visitado
            \node[fill=red!30] (E) at (9, 2) {E}; % Menor
            
            \draw[->] (A) -- node[above, font=\small]{4} (B); 
            \draw[->] (A) -- node[below, font=\small]{2} (C); 
            \draw[->] (B) -- node[left, font=\small]{1} (C);
            \draw[->,line width=2pt] (B) -- node[above, font=\small]{5} (D); 
            \draw[->] (C) -- node[below, font=\small]{8} (D);
            \draw[->] (C) -- node[below, font=\small]{10} (E);
            \draw[->,line width=2pt] (D) -- node[above, font=\small]{3} (E); % Caminho usado
        \end{tikzpicture}
    \end{column}
    \begin{column}{0.5\textwidth}
        \textbf{Visitando Nó: D} (dist=9)
        \begin{itemize}
            \item Vizinho E: $9 + 3 = 12$.
            \item O custo atual de E é 12. Como $12 \not< 12$, \textbf{não há atualização}.
        \end{itemize}
        \textbf{Visitando Nó: E} (dist=12)
        \begin{itemize}
            \item Fim do algoritmo (destino alcançado / fila vazia).
        \end{itemize}
        
                extbf{Nós Visitados: \{A, C, B, D, E\}}
        {\footnotesize\setlength{\tabcolsep}{6pt}\renewcommand{\arraystretch}{1.1}%
        \begin{tabular}{c|c|c}
    						extbf{Nó} & \textbf{dist[i]} & \textbf{prev[i]} \\ \hline
        A & 0 & - \\
        B & 4 & A \\
        C & 2 & A \\
        D & 9 & B \\
        E & 12 & C \\
        \end{tabular}}
    \end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Exercício: Dijkstra - Conclusão e Caminho}
\begin{block}{Resultado Final (Tabela)}
A tabela `dist` nos dá o custo mínimo de A para *todos* os outros nós:
\begin{itemize}
    \item Custo para B: 4
    \item Custo para C: 2
    \item Custo para D: 9
    \item Custo para E: 12
\end{itemize}
\end{block}

\begin{alertblock}{Encontrando o Caminho (Backtracking)}
Mas qual é o caminho de custo 12? Usamos a tabela `prev` de trás para frente:
\begin{enumerate}
    \item Começamos em \textbf{E}.
    \item Quem é o anterior (prev) de E? É o nó \textbf{C}. (Caminho: ... $\to C \to E$)
    \item Quem é o anterior (prev) de C? É o nó \textbf{A}. (Caminho: ... $\to A \to C \to E$)
    \item Chegamos na Origem (A). Fim.
\end{enumerate}
\textbf{Caminho Mínimo: $A \to C \to E$ \quad Custo Total: $2 + 10 = 12$}
\end{alertblock}
\end{frame}

% SLIDES 18-20: BELLMAN-FORD E COMPARATIVO
\begin{frame}
\frametitle{Algoritmo de Bellman-Ford}
\begin{block}{O Conceito}
Uma abordagem de \textbf{Programação Dinâmica}. Em vez de ser "guloso", ele é "pessimista" e re-calcula tudo várias vezes.
\end{block}

\begin{alertblock}{Principais Vantagens}
\begin{itemize}
    \item \textbf{Funciona com pesos negativos.}
    \item Consegue \textbf{detectar ciclos negativos} (um loop no grafo que, se percorrido, reduz o custo infinitamente).
\end{itemize}
\end{alertblock}

\begin{itemize}
    \item \textbf{Ideia Principal (Parte 1):}
    \begin{itemize}
        \item Repete o processo de "relaxar" \textbf{TODAS} as arestas do grafo, um total de $|V|-1$ vezes (onde $|V|$ é o número de nós).
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Algoritmo de Bellman-Ford}
\begin{itemize}
    \item \textbf{Ideia Principal (Parte 2):}
    \begin{itemize}
        \item \textbf{Por que $|V|-1$ vezes?} Porque o maior caminho mínimo possível *sem* um ciclo só pode ter, no máximo, $|V|-1$ arestas.
        \item Após as $|V|-1$ repetições, o algoritmo faz uma \textbf{última checagem} (uma $|V|$-ésima passagem).
        \item Se ainda for possível "relaxar" alguma aresta nessa última passagem, o algoritmo para e avisa: \textbf{"Ciclo Negativo Detectado!"}
    \end{itemize}
\end{itemize}

\begin{block}{Aplicação de Ciclo Negativo}
Isso é usado em finanças para detectar \textbf{arbitragem}: trocar Moeda A $\to$ Moeda B $\to$ Moeda C $\to$ Moeda A e sair com mais dinheiro do que começou.
\end{block}
\end{frame}

\begin{frame}
\frametitle{Comparativo: Dijkstra vs. Bellman-Ford}

\begin{table}[]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Característica} & \textbf{Algoritmo de Dijkstra} & \textbf{Algoritmo de Bellman-Ford} \\ \hline
\textbf{Abordagem} & Gulosa (Greedy) & Programação Dinâmica \\
\textbf{Pesos Negativos?} & \textbf{Não} (falha) & \textbf{Sim} \\
\textbf{Ciclos Negativos?} & Não (não detecta) & \textbf{Sim} (detecta) \\
\textbf{Complexidade} & $O(E \log V)$ ou $O(V^2)$ & $O(V \cdot E)$ \\
\textbf{Quando usar?} & Grafos sem pesos negativos & Grafos com pesos negativos \\
 & (Ex: GPS, redes OSPF) & (Ex: Detecção de arbitragem) \\ \hline
\end{tabular}
\end{table}

\vspace{0.5cm} % Diminuí o vspace para caber
\begin{block}{Conclusão}
A escolha do algoritmo depende da natureza do problema. Dijkstra é mais rápido, mas Bellman-Ford é mais robusto e "seguro" para grafos que podem ter custos negativos.
\end{block}
\end{frame}

% --- MÓDULO 4: REFERÊNCIAS BIBLIOGRÁFICAS ---

\section{Referências Bibliográficas}

% Adiciona [allowframebreaks] para que o beamer possa
% dividir a lista em múltiplos slides se ela for muito longa
\begin{frame}[allowframebreaks]
\frametitle{Referências Bibliográficas}

% Adicione este comando para mostrar TODAS as referências do seu arquivo ref.bib
\nocite{*}

% Este comando puxa as referências do seu arquivo ref.bib
% e as formata usando o estilo ABNT (definido no panqueques.sty)
\printbibliography

\end{frame}